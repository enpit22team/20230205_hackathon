# 第一回

## 最大公約数

- 入力：2つの整数nとm
- 出力：nとmの最大公約数
- **素朴な手順**
    
    純粋に割る数をi=1として、入力のうち小さい方の数と同じ値になるまでインクリメントして割っていく
    
    ```python
    def gcd (n, m):
    	if (n > m):
    		n, m = m, n
    	i = 1
    	while (i<=n):
    		if (n%i == 0 and m%i == 0):
    			gcd = i
    		i = i + 1
    	return gcd
    ```
    
- **ユーグリッドの互除法**
    - m > nを条件とする(m < nならスワップする)
    - mとnの最大公約数はnとr(=m%n)の最大公約数に等しいという事実を利用
        - 再帰的にm=n, n=m%nを代入してn=0になるまで繰り返す
    
    ```python
    def euclid (n, m):
    	if (n > m):
    		 n, m = m, n
    	while(n > 0):
    		m, n = n, m%n
    
    	return m
    
    ```
    

## 多項式の値の計算

- 入力
    - 多項式：$`p(x) = a_nx^n + a_{n-1}x^{n-1}+…+a_1x + a_0`$
    - 数
- 出力：$`p(x_0)`$
- **素朴な手順**
    1. pを0に初期化
    2. i=0からi=nまで$`a_ix^i`$を*`p`*に加算する
    
    ```python
    def polynomial (A,  x0):
    	p = 0
    	for i in range(n):
    		x = 1
    		for j in range(i):
    			x = x * x0
    		p = p + A[i] * x
    	return p
    ```
    
- **ホーナーの方法**
    1. $p(x) = a_nx^n+a_{n-1}x^{n-1}+…+a_1x+a_0$ 
    　　$= (((a_nx + a_{n-1})x + a_{n-2})x + …)x + a_0$
    2. 上記の式に従って、括弧の内側から足し算と掛け算の組み合わせを繰り返し行う
    
    ```python
    # A[i]が係数, xにx0を代入したときの値
    def horner (A, x0):
    	p = 0
    	for i in range(0):
    		p = (p + A[i]) * x0
    	return p
    ```
    

## 配列データの探索

- 入力
    - n個のデータの集合を格納した配列：A[0], …, A[n-1]
    - データ：d
- 出力：
    - 配列Aにデータdが存在するか否か
- **素朴な手順**
    
    線形探索：i=0~i=n-1について、A[i]=dが成り立つかチェックする
    
    ```python
    def linear_search (A, d):
    	for  i in range(len(A)):
    		if (A[i] == d) return True
    	return false
    ```
    
- **二分探索**
    - ソートして、配列の中身がdの方が大きければ右半分について再び検索、dのほうが小さかったら左半分について再び検索
    
    ```python
    # Aはソート済み配列とする
    def binary_search(A, d):
    	l = 0
    	h = n-1
    	while (l < h):
    		m = floor((l + h)/2) # 現在の探索範囲の真ん中
    		if (A[m] == d) return True
    		if (d < A[m]):
    			h = m - 1
    		else:
    			l = m + 1
    	if (A[l] == d) return True
    	return False
    		
    ```
    

## アルゴリズムが「正しい」とは

- 部分正当性
    - いかなる入力に対しても、間違った答えを出力しない
- 完全正当性
    - いかなる入力に対しても、間違った答えを出力しない
    - いかなる入力に対しても、有限時間で停止する
    

## 効率的なアルゴリズムの設計方法

- 数学的な事実を利用
    - ユーグリッドの互除法
    - 高速フーリエ変換
- 重複する計算を再利用
    - ホーナーの方法
    - ダイクストラ法
    - 動的計画法
- いらない計算を省く
    - 二分探索
    - ハッシュ法
    - クイックソート
    - 分割統治法

## アルゴリズムの良しあし

- 代表的な評価基準
    - 早く解を求められる
    - 少ない記憶領域で解を求められるほど良い
- アルゴリズム計算量
    - 時間計算量
    - 領域計算量
- 時間計算量を求める例
    - じっさいの実行時間はハードウェアなど環境に依存するため不適
    - 通常はアルゴリズム中のオーダー数に基づき見積もる
    - 最大公約数の場合
        - $f(n) = T_1 + T_2n$
        - T_1はループ以外の部分、T_2はループ内の必要時間

## 漸近的計算量

- 問題の規模が大きくなった時にどのように計算量が増加するかに注目

### O-記法(O-notation, ビッグオー記法)

- 計算量の漸近的上界
- 問題の規模`n`に対する計算量を`f(n)`. ある$`n_0`$と正定数`c`が存在し、$`n>n_0`$であるすべてのnに対して、$`f(n)\leq cg(n)`$が成り立つとき、$`f(n)=O(g(n))`$と表記
- **`f(n)`の中で、`n`に関して最も早く増加する項以外を削除して、その係数を無視したもの**
    - 最大公約数の例
        - $f(n) = T_1 + T_2n => O(n)$
    - $f(n) = 3n^2 + 4n + 2\log_2n +  3$
        - $⇒O(n^2)$
    

### Ω-記法(Ω-notation): あまり使われない

- 計算量の漸近的下界を与える
- 問題の規模`n`に対する計算量を`f(n)`. ある$`n_0`$と正定数`c`が存在し、無限個のnに対して、$`f(n)\geq cg(n)`$が成り立つとき、$`f(n)=O(g(n))`$と表記
- 通常は計算量の上界が注目されるので、特に断りがない場合はO-記法による計算量が用いられる
- アルゴリズムによっては同じサイズの入力データでも、データの内容によって計算量が変化することがある
